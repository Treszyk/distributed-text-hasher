<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0" />
		<title>Distributed Text Hasher</title>
		<style>
			body {
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
					sans-serif;
				margin: 0;
				padding: 0;
				background: #f5f5f5;
				height: 100vh;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}

			header {
				background: white;
				padding: 10px 20px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
				display: flex;
				justify-content: space-between;
				align-items: center;
				flex-shrink: 0;
				z-index: 10;
			}
			h1 {
				margin: 0;
				font-size: 18px;
				color: #333;
			}

			.stats-bar {
				display: flex;
				gap: 20px;
				font-size: 14px;
			}
			.stat-item {
				display: flex;
				align-items: center;
				gap: 5px;
				color: #666;
			}
			.stat-value {
				font-weight: bold;
				color: #007bff;
				font-family: monospace;
			}

			main {
				flex-grow: 1;
				padding: 15px;
				display: flex;
				flex-direction: column;
				gap: 15px;
				max-width: 1200px;
				width: 100%;
				margin: 0 auto;
				box-sizing: border-box;
				overflow: hidden;
			}

			.input-section {
				background: white;
				padding: 10px;
				border-radius: 6px;
				display: flex;
				gap: 10px;
				align-items: center;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
				flex-shrink: 0;
			}
			input[type='text'] {
				flex-grow: 1;
				padding: 8px 12px;
				border: 1px solid #ddd;
				border-radius: 4px;
			}
			button {
				padding: 8px 16px;
				background: #007bff;
				color: white;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
				white-space: nowrap;
			}
			button:hover {
				background: #0056b3;
			}
			button.secondary {
				background: #6c757d;
			}
			button.secondary:hover {
				background: #545b62;
			}
			button.danger {
				background: #dc3545;
			}
			button.danger:hover {
				background: #c82333;
			}

			.board-container {
				flex-grow: 1;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}
			.board-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 10px;
				flex-shrink: 0;
			}
			.board-title {
				font-weight: bold;
				color: #555;
			}

			.kanban-board {
				display: grid;
				grid-template-columns: repeat(3, 1fr);
				gap: 15px;
				flex-grow: 1;
				overflow: hidden;
			}

			.kanban-column {
				background: #e9ecef;
				border-radius: 6px;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}

			.column-header {
				padding: 10px;
				font-weight: bold;
				text-align: center;
				background: rgba(255, 255, 255, 0.5);
				border-bottom: 1px solid rgba(0, 0, 0, 0.05);
				flex-shrink: 0;
			}
			.status-queued {
				color: #d39e00;
			}
			.status-processing {
				color: #17a2b8;
			}
			.status-done {
				color: #28a745;
			}

			.job-list {
				flex-grow: 1;
				overflow-y: auto;
				padding: 10px;
			}

			.job-card {
				background: white;
				padding: 10px;
				margin-bottom: 8px;
				border-radius: 4px;
				box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
				font-size: 13px;
				border-left: 3px solid transparent;
			}
			.job-card:hover {
				transform: translateY(-1px);
				box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
			}
			.status-queued .job-card {
				border-left-color: #ffc107;
			}

			.card-top {
				display: flex;
				justify-content: space-between;
				margin-bottom: 4px;
				color: #888;
				font-size: 11px;
			}
			.card-id {
				font-family: monospace;
			}
			.card-content {
				font-weight: 500;
				color: #333;
				margin-bottom: 5px;
				word-break: break-word;
			}
			.card-hash {
				font-family: monospace;
				background: #f8f9fa;
				padding: 4px;
				border-radius: 3px;
				font-size: 11px;
				color: #28a745;
				word-break: break-all;
			}
		</style>
	</head>
	<body>
		<header>
			<h1>Distributed Text Hasher</h1>
			<div class="stats-bar">
				<div
					class="stat-item"
					style="margin-right: 15px">
					<label class="switch">
						<input
							type="checkbox"
							id="scalingToggle"
							onclick="toggleScaling()" />
						<span class="slider round"></span>
					</label>
					<div style="display: flex; flex-direction: column; line-height: 1">
						<span style="font-size: 12px; margin-left: 5px">Autoscaling</span>
						<span
							id="scalerStatus"
							style="
								font-size: 10px;
								margin-left: 5px;
								color: #888;
								font-style: italic;
								white-space: nowrap;
							"></span>
					</div>
				</div>
				<div class="stat-item">
					<span>Workers:</span>
					<span
						id="activeWorkers"
						class="stat-value"
						>-</span
					>
				</div>
				<div class="stat-item">
					<span>Queue:</span>
					<span
						id="queueLength"
						class="stat-value"
						>-</span
					>
				</div>
			</div>
		</header>

		<style>
			.switch {
				position: relative;
				display: inline-block;
				width: 34px;
				height: 20px;
				vertical-align: middle;
			}
			.switch input {
				opacity: 0;
				width: 0;
				height: 0;
			}
			.slider {
				position: absolute;
				cursor: pointer;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-color: #ccc;
				transition: 0.4s;
				border-radius: 34px;
			}
			.slider:before {
				position: absolute;
				content: '';
				height: 14px;
				width: 14px;
				left: 3px;
				bottom: 3px;
				background-color: white;
				transition: 0.4s;
				border-radius: 50%;
			}
			input:checked + .slider {
				background-color: #2196f3;
			}
			input:checked + .slider:before {
				transform: translateX(14px);
			}
		</style>

		<main>
			<div class="input-section">
				<input
					type="text"
					id="jobText"
					placeholder="Enter text to hash..."
					onkeypress="if(event.key==='Enter') createJob()" />
				<button onclick="createJob()">Submit</button>
				<div
					style="
						width: 1px;
						height: 20px;
						background: #ddd;
						margin: 0 5px;
					"></div>
				<button
					class="secondary"
					onclick="floodJobs(50)">
					Flood (50)
				</button>

				<div
					style="
						width: 1px;
						height: 20px;
						background: #ddd;
						margin: 0 5px;
					"></div>

				<input
					type="file"
					id="fileUpload"
					accept=".txt"
					style="display: none"
					onchange="handleFileUpload(this)" />
				<button
					class="secondary"
					onclick="document.getElementById('fileUpload').click()"
					title="Upload a .txt file with one text per line">
					Upload File
				</button>
				<button
					class="secondary"
					onclick="exportResults()"
					title="Download hashes of completed jobs">
					Export Results
				</button>
			</div>

			<div class="board-container">
				<div class="board-header">
					<span class="board-title"
						>My Jobs
						<span
							id="jobCount"
							style="font-weight: normal; color: #888"
							>(0)</span
						></span
					>
					<div>
						<button
							class="secondary"
							onclick="clearJobs()"
							style="font-size: 12px; padding: 4px 8px">
							Clear Local
						</button>
						<button
							class="danger"
							onclick="clearQueue()"
							style="font-size: 12px; padding: 4px 8px">
							Clear Server Queue
						</button>
					</div>
				</div>

				<div class="kanban-board">
					<div class="kanban-column">
						<div class="column-header status-queued">
							Queued <span id="count-queued"></span>
						</div>
						<div
							id="list-queued"
							class="job-list"></div>
					</div>
					<div class="kanban-column">
						<div class="column-header status-processing">
							Processing <span id="count-processing"></span>
						</div>
						<div
							id="list-processing"
							class="job-list"></div>
					</div>
					<div class="kanban-column">
						<div class="column-header status-done">
							Done <span id="count-done"></span>
						</div>
						<div
							id="list-done"
							class="job-list"></div>
					</div>
				</div>
			</div>
		</main>

		<script>
			let myJobs = [];
			const API_URL = '';
			const MAX_JOBS = 1000;

			async function createJob(textOverride = null) {
				const input = document.getElementById('jobText');
				const text = textOverride || input.value;
				if (!text) return;

				try {
					const res = await fetch(`${API_URL}/jobs/text`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ text, algorithm: 'sha256' }),
					});
					const data = await res.json();

					myJobs.unshift({
						jobId: data.jobId,
						status: 'queued',
						text: text.substring(0, 50),
						timestamp: Date.now(),
					});
					pruneJobs();
					renderJobs();
					if (!textOverride) input.value = '';
				} catch (err) {
					console.error(err);
				}
			}

			async function handleFileUpload(input) {
				const file = input.files[0];
				if (!file) return;

				const reader = new FileReader();
				reader.onload = async (e) => {
					const text = e.target.result;
					const lines = text
						.split(/\r?\n/)
						.filter((line) => line.trim() !== '');

					if (lines.length === 0) {
						alert('File is empty');
						return;
					}

					if (
						lines.length > 500 &&
						!confirm(`File contains ${lines.length} lines. Continue?`)
					) {
						input.value = '';
						return;
					}

					for (const line of lines) {
						await createJob(line.trim());
						await new Promise((r) => setTimeout(r, 20));
					}

					input.value = '';
				};
				reader.readAsText(file);
			}

			function exportResults() {
				const doneJobs = myJobs.filter((j) => j.status === 'done');
				if (doneJobs.length === 0) {
					alert('No completed jobs to export.');
					return;
				}

				const content = doneJobs.map((j) => `${j.text} : ${j.hash}`).join('\n');

				const blob = new Blob([content], { type: 'text/plain' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = `hashes_${Date.now()}.txt`;
				a.click();
				URL.revokeObjectURL(url);
			}

			async function floodJobs(count) {
				const baseText = 'Flood task ' + Date.now();
				for (let i = 0; i < count; i++) {
					createJob(`${baseText} #${i + 1}`);
				}
			}

			async function clearQueue() {
				if (!confirm('Clear all pending jobs from server?')) return;
				try {
					await fetch(`${API_URL}/queue`, { method: 'DELETE' });
				} catch (err) {
					alert('Failed to clear queue');
				}
			}

			function pruneJobs() {
				if (myJobs.length <= MAX_JOBS) return;

				const active = myJobs.filter(
					(j) => j.status !== 'done' && j.status !== 'failed'
				);
				const done = myJobs.filter(
					(j) => j.status === 'done' || j.status === 'failed'
				);

				if (active.length >= MAX_JOBS) {
					myJobs = active.slice(0, MAX_JOBS);
				} else {
					const slotsForDone = MAX_JOBS - active.length;
					const keptDone = done.slice(0, slotsForDone);

					myJobs = [...active, ...keptDone].sort(
						(a, b) => b.timestamp - a.timestamp
					);
				}
			}

			async function updateStats() {
				try {
					const res = await fetch(`${API_URL}/stats`);
					const data = await res.json();
					document.getElementById('activeWorkers').textContent =
						data.activeWorkers;
					document.getElementById('queueLength').textContent = data.queueLength;

					const statusEl = document.getElementById('scalerStatus');
					if (data.scalerStatus === 'scaling_up') {
						statusEl.textContent = 'Scaling Up ▲';
						statusEl.style.color = '#28a745';
					} else if (data.scalerStatus === 'scaling_down') {
						statusEl.textContent = 'Scaling Down ▼';
						statusEl.style.color = '#dc3545';
					} else if (data.scalerStatus === 'paused') {
						statusEl.textContent = 'Paused';
						statusEl.style.color = '#6c757d';
					} else {
						statusEl.textContent = '';
					}
				} catch (err) {
					console.error('Stats error', err);
				}
			}

			async function pollJobs() {
				const activeJobs = myJobs.filter(
					(j) => j.status !== 'done' && j.status !== 'failed'
				);
				if (activeJobs.length === 0) return;

				const jobIds = activeJobs.map((j) => j.jobId);

				try {
					const res = await fetch(`${API_URL}/jobs/batch`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ jobIds }),
					});
					const updates = await res.json();

					let hasChanges = false;
					updates.forEach((update) => {
						const index = myJobs.findIndex((j) => j.jobId === update.jobId);
						if (index !== -1) {
							if (myJobs[index].status !== update.status) {
								myJobs[index] = { ...myJobs[index], ...update };
								hasChanges = true;
							}
						}
					});

					if (hasChanges) renderJobs();
				} catch (err) {
					console.error('Batch poll error', err);
				}
			}

			function renderJobs() {
				document.getElementById('jobCount').textContent = `(${myJobs.length})`;

				const lists = {
					queued: document.getElementById('list-queued'),
					processing: document.getElementById('list-processing'),
					done: document.getElementById('list-done'),
				};

				const counts = { queued: 0, processing: 0, done: 0 };

				Object.values(lists).forEach((el) => (el ? (el.innerHTML = '') : null));

				myJobs.forEach((job) => {
					let status = job.status === 'failed' ? 'done' : job.status;
					if (!lists[status]) status = 'queued';

					counts[status]++;
					const targetList = lists[status];

					if (targetList) {
						const card = document.createElement('div');
						card.className = 'job-card';
						card.innerHTML = `
                            <div class="card-top">
                                <span class="card-id">${
																	job.jobId.split('-')[0]
																}</span>
                                <span class="worker-badge">${
																	job.workerId || ''
																}</span>
                            </div>
                            <div class="card-content">${
															job.textPreview || job.text || '...'
														}</div>
                            ${
															job.hash
																? `<div class="card-hash">${job.hash.substring(
																		0,
																		20
																  )}...</div>`
																: ''
														}
                        `;
						targetList.appendChild(card);
					}
				});

				document.getElementById(
					'count-queued'
				).textContent = `(${counts.queued})`;
				document.getElementById(
					'count-processing'
				).textContent = `(${counts.processing})`;
				document.getElementById('count-done').textContent = `(${counts.done})`;
			}

			function clearJobs() {
				myJobs = [];
				renderJobs();
			}

			async function toggleScaling() {
				const toggle = document.getElementById('scalingToggle');
				const enabled = toggle.checked;

				try {
					await fetch(`${API_URL}/admin/scaling`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ enabled }),
					});
				} catch (err) {
					toggle.checked = !enabled;
					alert('Failed to update scaling config');
				}
			}

			async function initScalingState() {
				try {
					const res = await fetch(`${API_URL}/admin/scaling`);
					const data = await res.json();
					document.getElementById('scalingToggle').checked = data.enabled;
				} catch (err) {
					console.error(err);
				}
			}

			initScalingState();
			renderJobs();
			setInterval(updateStats, 1000);
			setInterval(pollJobs, 2000);
			updateStats();
		</script>
	</body>
</html>
